var documenterSearchIndex = {"docs":
[{"location":"#Collects","page":"Home","title":"Collects","text":"Collects.jl is a software package for the Julia programming language. It provides functionality and interfaces for collecting the elements of an arbitrary collection into another collection of a specified type. The exported interfaces generalize the collect function from Base Julia in several ways.\n\n","category":"section"},{"location":"#Exported-functionality","page":"Home","title":"Exported functionality","text":"collect_as, a function: the user-level interface\nCollect, a type: the lower-level interface, meant primarily for adding methods for package authors\nEmptyIteratorHandling, a module exporting the following:\njust_throws\nmay_use_type_inference\n\nA core idea of the Collects.jl interface, is that the implementation for each output type should work correctly independently of the type of the input collection. Each implementation attempts to treat the input collection completely generically, except possibly as a performance improvement.\n\nThis package is intended to be an interface package, only implementing its interface for output types that come with Julia. Currently this includes:\n\nSet and subtypes, such as Set{Float64}\nArray and subtypes, such as Vector{Float64}\nMemory and subtypes, such as Memory{Float64}\nTuple\n\nThird-party packages are invited to add the Collects.jl package as a (weak or strong) dependency and implement its interface for their types. Some examples:\n\nFixedSizeArrays.jl implements the Collects.jl interface for FixedSizeArray output","category":"section"},{"location":"#Doc-strings","page":"Home","title":"Doc strings","text":"","category":"section"},{"location":"#Usage-examples","page":"Home","title":"Usage examples","text":"The collect_as function takes two positional arguments:\n\nthe output type\nan arbitrary iterator\n\nIt collects the elements of the iterator into a collection with the provided output type as the type of the collection.\n\njulia> it = Iterators.map((x -> 0.5 * x), [2, 2, 3]);\n\njulia> collect_as(Vector, it)\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.5\n\njulia> collect_as(Vector{Float32}, it)\n3-element Vector{Float32}:\n 1.0\n 1.0\n 1.5\n\njulia> collect_as(Set, it)\nSet{Float64} with 2 elements:\n  1.0\n  1.5\n\njulia> collect_as(Set, [])\nERROR: ArgumentError: couldn't figure out an appropriate element type\n[...]\n\njulia> collect_as(Set{Number}, [])\nSet{Number}()\n\nThe behavior for an empty iterator when the element type is not known may be adjusted by passing a keyword argument:\n\njulia> collect_as(Set, []; empty_iterator_handler = Returns(Union{}))\nSet{Union{}}()\n\njulia> collect_as(Set, Iterators.map((x -> 0.5 * x), 1:0); empty_iterator_handler = EmptyIteratorHandling.may_use_type_inference)\nSet{Float64}()\n\nNB: behavior may depend on Julia implementation details when using may_use_type_inference.\n\nIt's also possible to collect into a collection with a dimensionality greater than one, assuming the shape can be inferred:\n\njulia> collect_as(Matrix, Iterators.map(cos, rand(2, 2)))\n2×2 Matrix{Float64}:\n 0.792873  0.781535\n 0.553728  0.941229\n\nThe collect_as function just forwards to the lower-level interface around Collect. The lower level interface is used like so:\n\njulia> c = Collect(; empty_iterator_handler = EmptyIteratorHandling.just_throws);\n\njulia> c(Vector, (3, 3.0))\n2-element Vector{Real}:\n 3\n 3.0\n\ncollect_as additionally allows being called with only one argument, like collect_as(output_type). collect_as(t) behaves very similarly to Base.Fix1(collect_as, t), basically it is a partial application of the function. Example:\n\njulia> c = collect_as(Vector);\n\njulia> m = c ∘ Iterators.map;\n\njulia> m(sin, 0:3)\n4-element Vector{Float64}:\n 0.0\n 0.8414709848078965\n 0.9092974268256817\n 0.1411200080598672","category":"section"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"The motivation for creating this package is overcoming these issues of the collect interface:\n\nThe collect function allows the caller to specify the desired element type, but does not allow specifying the desired container type.\nThe interface in this package allows the caller to specify the desired output type, not just the element type.\nThis package implements the interface for several Base types and invites other packages to implement the interface for their own types.\nThis is basically Julia issue #36288 by Takafumi Arakaki.\nThe collect function may rely on type inference to determine the element type of the output type when the iterator is empty and the element type was not specified by the caller.\nThis package lets the caller decide how the element type of an empty iterator is determined.\nBy default, type inference is not used.\nBy default, an ArgumentError is thrown in case a good element type can not be determined.\n\nCollects.jl aims to provide a better interface to replace collect.","category":"section"},{"location":"#How-to-implement-for-your-collection-type","page":"Home","title":"How to implement for your collection type","text":"To implement the interface for one's own container type, say Collection, define a method like this:\n\nfunction (c::Collect)(t::Type{<:Collection}, iterator::Any)\n    ...\nend\n\nWhen iterator turns out to be empty, and eltype(iterator) is neither the bottom type nor concrete, and t does not specify an element type, call (c.empty_iterator_handler)(iterator) to try to obtain the element type.","category":"section"},{"location":"#Rough-specification","page":"Home","title":"Rough specification","text":"","category":"section"},{"location":"#Identity","page":"Home","title":"Identity","text":"If iterator isa output_type already, a (shallow) copy of iterator must be returned.","category":"section"},{"location":"#Return-type","page":"Home","title":"Return type","text":"For each c, output_type and iterator such that c isa Collect, if c(output_type, iterator) returns a value, the value must be of type output_type.","category":"section"},{"location":"#Element-type-of-the-output","page":"Home","title":"Element type of the output","text":"The element type must be consistent with output_type (as already implied above).\n\nIf the output element type does not supertype the element type of iterator, the elements of iterator are converted into the output element type.\n\nRule for determining the element type of the output (when applicable, that is, when the output type depends on its element type, and the output type does not subtype Tuple):\n\nIf the element type is specified by output_type, it's the element type of the output.\nOtherwise, if iterator is empty:\nIf isconcretetype(eltype(iterator)) || (eltype(iterator) <: Union{}), eltype(iterator) is the output element type.\nOtherwise, the output element type must be determined by (c.empty_iterator_handler)(iterator).\nOtherwise, the output element type is the typejoin of the types of the elements of iterator.","category":"section"},{"location":"#Shape-of-the-output","page":"Home","title":"Shape of the output","text":"The shape of the output must be consistent with output_type (as already implied above).\n\nTo the extent that the shape is not specified by output_type, it is inferred from Base.IteratorSize(iterator).","category":"section"},{"location":"#Other-rules-for-implementers-to-follow","page":"Home","title":"Other rules for implementers to follow","text":"Any added method must take exactly two arguments.\n\nIf you disagree, open a feature request on Github to achieve agreement for adding to the interface.\n\nThe first argument of any added method must be constrained to be a type (of type Type).\n\nMake sure you own the constraint that is placed on the first argument. This is required even when you know you own the second argument.\n\nThe rationale for this rule is to prevent causing ambiguity for other packages.\nFor example, defining a method with a signature like here is not allowed, because you do not own Vector, even if you do own A:\nfunction (::Collect)(::Type{Vector}, ::A) end","category":"section"},{"location":"#Collects.Collect","page":"Home","title":"Collects.Collect","text":"Collect(; empty_iterator_handler)\n\nReturn a callable value. The returned callable behaves similarly to the collect function from Base. In fact it generalizes collect, and is meant to be what collect should have been. See the package Readme for more details.\n\nThe keyword argument empty_iterator_handler:\n\nconfigures how the returned callable will behave when called with an empty iterator\nis accessible as a property of any Collect value\n\n\n\n\n\n","category":"type"},{"location":"#Collects.collect_as-Union{Tuple{EIH}, Tuple{T}, Tuple{Type{T}, Any}} where {T, EIH}","page":"Home","title":"Collects.collect_as","text":"collect_as(output_type::Type, collection; empty_iterator_handler)\n\nCollect collection into a collection of type output_type. The optional keyword argument empty_iterator_handler may be used to control the behavior for when collection is empty.\n\nDo not add any method. This function just forwards to Collect.\n\n\n\n\n\n","category":"method"},{"location":"#Collects.collect_as-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"Collects.collect_as","text":"collect_as(output_type::Type)\n\nReturn a callable which:\n\nTakes a collection, collection, as the only positional argument.\nTakes the same keyword arguments as the collect_as method with two positional arguments. Say, kwargs.\nCalls collect_as(output_type, collection; kwargs...) and returns the result.\n\nMostly equivalent to Base.Fix1(collect_as, output_type).\n\n\n\n\n\n","category":"method"},{"location":"#Collects.EmptyIteratorHandling.just_throws-Tuple{Any}","page":"Home","title":"Collects.EmptyIteratorHandling.just_throws","text":"just_throws(iterator)::Union{}\n\nThrow an ArgumentError.\n\n\n\n\n\n","category":"method"},{"location":"#Collects.EmptyIteratorHandling.may_use_type_inference-Tuple{Any}","page":"Home","title":"Collects.EmptyIteratorHandling.may_use_type_inference","text":"may_use_type_inference(iterator)::Type\n\nRun type inference to try to determine the element type. If the obtained type is either concrete or bottom, return it, or an equal type.\n\nThrow otherwise.\n\nBeware:\n\nType inference is accessed using Base.@default_eltype, which is not a public interface of Base, thus it may change behavior on upgrading Julia, potentially breaking this function.\nThe exact result of a type inference query is, of course, just an implementation detail of Julia's compiler.\nType inference results may differ from run to run. Type inference is stateful, some things that may affect the results of a type inference query are: defining a method, loading a package or running a type inference query.\nRelying on type inference may prevent compiler optimizations, such as constant folding.\nPublicly exposing the results of type inference makes for a bad interface. Only use it as an optimization.\n\n\n\n\n\n","category":"method"}]
}
