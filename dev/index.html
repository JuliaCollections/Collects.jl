<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Collects.jl</title><meta name="title" content="Home · Collects.jl"/><meta property="og:title" content="Home · Collects.jl"/><meta property="twitter:title" content="Home · Collects.jl"/><meta name="description" content="Documentation for Collects.jl."/><meta property="og:description" content="Documentation for Collects.jl."/><meta property="twitter:description" content="Documentation for Collects.jl."/><meta property="og:url" content="https://JuliaCollections.github.io/Collects.jl/"/><meta property="twitter:url" content="https://JuliaCollections.github.io/Collects.jl/"/><link rel="canonical" href="https://JuliaCollections.github.io/Collects.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Collects.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Exported-functionality"><span>Exported functionality</span></a></li><li><a class="tocitem" href="#Usage-examples"><span>Usage examples</span></a></li><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#How-to-implement-for-your-collection-type"><span>How to implement for your collection type</span></a></li><li><a class="tocitem" href="#Rough-specification"><span>Rough specification</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCollections/Collects.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCollections/Collects.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Collects"><a class="docs-heading-anchor" href="#Collects">Collects</a><a id="Collects-1"></a><a class="docs-heading-anchor-permalink" href="#Collects" title="Permalink"></a></h1><p><a href="https://github.com/JuliaCollections/Collects.jl">Collects.jl</a> is a software package for the <a href="https://julialang.org">Julia</a> programming language. It provides functionality and interfaces for collecting the elements of an arbitrary collection into another collection of a specified type. The exported interfaces generalize the <code>collect</code> function from <code>Base</code> Julia in several ways.</p><h2 id="Exported-functionality"><a class="docs-heading-anchor" href="#Exported-functionality">Exported functionality</a><a id="Exported-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functionality" title="Permalink"></a></h2><ul><li><p><code>collect_as</code>, a function: the user-level interface</p></li><li><p><code>Collect</code>, a type: the lower-level interface, meant primarily for adding methods for package authors</p></li><li><p><code>EmptyIteratorHandling</code>, a module exporting the following:</p><ul><li><p><code>just_throws</code></p></li><li><p><code>may_use_type_inference</code></p></li></ul></li></ul><p>A core idea of the Collects.jl interface, is that the implementation for each output type should work correctly independently of the type of the input collection. Each implementation attempts to treat the input collection completely generically, except possibly as a performance improvement.</p><p>This package is intended to be an interface package, only implementing its interface for output types that come with Julia. Currently this includes:</p><ul><li><p><code>Set</code> and subtypes, such as <code>Set{Float64}</code></p></li><li><p><code>Array</code> and subtypes, such as <code>Vector{Float64}</code></p></li><li><p><code>Memory</code> and subtypes, such as <code>Memory{Float64}</code></p></li><li><p><code>Tuple</code></p></li></ul><p>Third-party packages are invited to add the Collects.jl package as a (weak or strong) dependency and implement its interface for their types. Some examples:</p><ul><li><a href="https://github.com/JuliaArrays/FixedSizeArrays.jl">FixedSizeArrays.jl</a> implements the Collects.jl interface for <code>FixedSizeArray</code> output</li></ul><h3 id="Doc-strings"><a class="docs-heading-anchor" href="#Doc-strings">Doc strings</a><a id="Doc-strings-1"></a><a class="docs-heading-anchor-permalink" href="#Doc-strings" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="Collects.Collect"><a class="docstring-binding" href="#Collects.Collect"><code>Collects.Collect</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Collect(; empty_iterator_handler)</code></pre><p>Return a callable value. The returned callable behaves similarly to the <code>collect</code> function from <code>Base</code>. In fact it generalizes <code>collect</code>, and is meant to be <em>what <code>collect</code> should have been</em>. See the package Readme for more details.</p><p>The keyword argument <code>empty_iterator_handler</code>:</p><ul><li><p>configures how the returned callable will behave when called with an empty iterator</p></li><li><p>is accessible as a property of any <code>Collect</code> value</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/Collects.jl/blob/51039e6b9dd57fc1861ba283824a81d4efc27412/src/Collects.jl#L79-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Collects.collect_as-Union{Tuple{EIH}, Tuple{T}, Tuple{Type{T}, Any}} where {T, EIH}"><a class="docstring-binding" href="#Collects.collect_as-Union{Tuple{EIH}, Tuple{T}, Tuple{Type{T}, Any}} where {T, EIH}"><code>Collects.collect_as</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">collect_as(output_type::Type, collection; empty_iterator_handler)</code></pre><p>Collect <code>collection</code> into a collection of type <code>output_type</code>. The optional keyword argument <code>empty_iterator_handler</code> may be used to control the behavior for when <code>collection</code> is empty.</p><p>Do not add any method. This function just forwards to <a href="#Collects.Collect"><code>Collect</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/Collects.jl/blob/51039e6b9dd57fc1861ba283824a81d4efc27412/src/Collects.jl#L510-L518">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Collects.collect_as-Union{Tuple{Type{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Collects.collect_as-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Collects.collect_as</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">collect_as(output_type::Type)</code></pre><p>Return a callable which:</p><ul><li><p>Takes a collection, <code>collection</code>, as the only positional argument.</p></li><li><p>Takes the same keyword arguments as the <code>collect_as</code> method with two positional arguments. Say, <code>kwargs</code>.</p></li><li><p>Calls <code>collect_as(output_type, collection; kwargs...)</code> and returns the result.</p></li></ul><p>Mostly equivalent to <code>Base.Fix1(collect_as, output_type)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/Collects.jl/blob/51039e6b9dd57fc1861ba283824a81d4efc27412/src/Collects.jl#L524-L536">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Collects.EmptyIteratorHandling.just_throws-Tuple{Any}"><a class="docstring-binding" href="#Collects.EmptyIteratorHandling.just_throws-Tuple{Any}"><code>Collects.EmptyIteratorHandling.just_throws</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">just_throws(iterator)::Union{}</code></pre><p>Throw an <code>ArgumentError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/Collects.jl/blob/51039e6b9dd57fc1861ba283824a81d4efc27412/src/Collects.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Collects.EmptyIteratorHandling.may_use_type_inference-Tuple{Any}"><a class="docstring-binding" href="#Collects.EmptyIteratorHandling.may_use_type_inference-Tuple{Any}"><code>Collects.EmptyIteratorHandling.may_use_type_inference</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">may_use_type_inference(iterator)::Type</code></pre><p>Run type inference to try to determine the element type. If the obtained type is either concrete or bottom, return it, or an equal type.</p><p>Throw otherwise.</p><p>Beware:</p><ul><li><p>Type inference is accessed using <code>Base.@default_eltype</code>, which is not a public interface of <code>Base</code>, thus it may change behavior on upgrading Julia, potentially breaking this function.</p></li><li><p>The exact result of a type inference query is, of course, just an implementation detail of Julia&#39;s compiler.</p></li><li><p>Type inference results may differ from run to run. Type inference is stateful, some things that may affect the results of a type inference query are: defining a method, loading a package or running a type inference query.</p></li><li><p>Relying on type inference may prevent compiler optimizations, such as constant folding.</p></li><li><p>Publicly exposing the results of type inference makes for a bad interface. Only use it as an optimization.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/Collects.jl/blob/51039e6b9dd57fc1861ba283824a81d4efc27412/src/Collects.jl#L38-L64">source</a></section></details></article><h2 id="Usage-examples"><a class="docs-heading-anchor" href="#Usage-examples">Usage examples</a><a id="Usage-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-examples" title="Permalink"></a></h2><p>The <code>collect_as</code> function takes two positional arguments:</p><ul><li><p>the output type</p></li><li><p>an arbitrary iterator</p></li></ul><p>It collects the elements of the iterator into a collection with the provided output type as the type of the collection.</p><pre><code class="language-julia-repl hljs">julia&gt; it = Iterators.map((x -&gt; 0.5 * x), [2, 2, 3]);

julia&gt; collect_as(Vector, it)
3-element Vector{Float64}:
 1.0
 1.0
 1.5

julia&gt; collect_as(Vector{Float32}, it)
3-element Vector{Float32}:
 1.0
 1.0
 1.5

julia&gt; collect_as(Set, it)
Set{Float64} with 2 elements:
  1.0
  1.5

julia&gt; collect_as(Set, [])
ERROR: ArgumentError: couldn&#39;t figure out an appropriate element type
[...]

julia&gt; collect_as(Set{Number}, [])
Set{Number}()</code></pre><p>The behavior for an empty iterator when the element type is not known may be adjusted by passing a keyword argument:</p><pre><code class="language-julia-repl hljs">julia&gt; collect_as(Set, []; empty_iterator_handler = Returns(Union{}))
Set{Union{}}()

julia&gt; collect_as(Set, Iterators.map((x -&gt; 0.5 * x), 1:0); empty_iterator_handler = EmptyIteratorHandling.may_use_type_inference)
Set{Float64}()</code></pre><p>NB: behavior may depend on Julia implementation details when using <code>may_use_type_inference</code>.</p><p>It&#39;s also possible to collect into a collection with a dimensionality greater than one, assuming the shape can be inferred:</p><pre><code class="language-julia-repl hljs">julia&gt; collect_as(Matrix, Iterators.map(cos, rand(2, 2)))
2×2 Matrix{Float64}:
 0.792873  0.781535
 0.553728  0.941229</code></pre><p>The <code>collect_as</code> function just forwards to the lower-level interface around <code>Collect</code>. The lower level interface is used like so:</p><pre><code class="language-julia-repl hljs">julia&gt; c = Collect(; empty_iterator_handler = EmptyIteratorHandling.just_throws);

julia&gt; c(Vector, (3, 3.0))
2-element Vector{Real}:
 3
 3.0</code></pre><p><code>collect_as</code> additionally allows being called with only one argument, like <code>collect_as(output_type)</code>. <code>collect_as(t)</code> behaves very similarly to <code>Base.Fix1(collect_as, t)</code>, basically it is a partial application of the function. Example:</p><pre><code class="language-julia-repl hljs">julia&gt; c = collect_as(Vector);

julia&gt; m = c ∘ Iterators.map;

julia&gt; m(sin, 0:3)
4-element Vector{Float64}:
 0.0
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672</code></pre><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>The motivation for creating this package is overcoming these issues of the <code>collect</code> interface:</p><ul><li><p>The <code>collect</code> function allows the caller to specify the desired element type, but does not allow specifying the desired container type.</p><ul><li><p>The interface in this package allows the caller to specify the desired output type, not just the element type.</p></li><li><p>This package implements the interface for several <code>Base</code> types and invites other packages to implement the interface for their own types.</p></li><li><p>This is basically Julia issue <a href="https://github.com/JuliaLang/julia/issues/36288">#36288</a> by Takafumi Arakaki.</p></li></ul></li><li><p>The <code>collect</code> function may rely on type inference to determine the element type of the output type when the iterator is empty and the element type was not specified by the caller.</p><ul><li><p>This package lets the caller decide how the element type of an empty iterator is determined.</p><ul><li><p>By default, type inference is not used.</p></li><li><p>By default, an <code>ArgumentError</code> is thrown in case a good element type can not be determined.</p></li></ul></li></ul></li></ul><p>Collects.jl aims to provide a better interface to replace <code>collect</code>.</p><h2 id="How-to-implement-for-your-collection-type"><a class="docs-heading-anchor" href="#How-to-implement-for-your-collection-type">How to implement for your collection type</a><a id="How-to-implement-for-your-collection-type-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-implement-for-your-collection-type" title="Permalink"></a></h2><p>To implement the interface for one&#39;s own container type, say <code>Collection</code>, define a method like this:</p><pre><code class="language-julia hljs">function (c::Collect)(t::Type{&lt;:Collection}, iterator::Any)
    ...
end</code></pre><p>When <code>iterator</code> turns out to be empty, and <code>eltype(iterator)</code> is neither the bottom type nor concrete, and <code>t</code> does not specify an element type, call <code>(c.empty_iterator_handler)(iterator)</code> to try to obtain the element type.</p><h2 id="Rough-specification"><a class="docs-heading-anchor" href="#Rough-specification">Rough specification</a><a id="Rough-specification-1"></a><a class="docs-heading-anchor-permalink" href="#Rough-specification" title="Permalink"></a></h2><h3 id="Identity"><a class="docs-heading-anchor" href="#Identity">Identity</a><a id="Identity-1"></a><a class="docs-heading-anchor-permalink" href="#Identity" title="Permalink"></a></h3><p>If <code>iterator isa output_type</code> already, a (shallow) copy of <code>iterator</code> must be returned.</p><h3 id="Return-type"><a class="docs-heading-anchor" href="#Return-type">Return type</a><a id="Return-type-1"></a><a class="docs-heading-anchor-permalink" href="#Return-type" title="Permalink"></a></h3><p>For each <code>c</code>, <code>output_type</code> and <code>iterator</code> such that <code>c isa Collect</code>, if <code>c(output_type, iterator)</code> returns a value, the value must be of type <code>output_type</code>.</p><h3 id="Element-type-of-the-output"><a class="docs-heading-anchor" href="#Element-type-of-the-output">Element type of the output</a><a id="Element-type-of-the-output-1"></a><a class="docs-heading-anchor-permalink" href="#Element-type-of-the-output" title="Permalink"></a></h3><p>The element type must be consistent with <code>output_type</code> (as already implied above).</p><p>If the output element type does not supertype the element type of <code>iterator</code>, the elements of <code>iterator</code> are converted into the output element type.</p><p>Rule for determining the element type of the output (when applicable, that is, when the output type depends on its element type, and the output type does not subtype <code>Tuple</code>):</p><ul><li><p>If the element type is specified by <code>output_type</code>, it&#39;s the element type of the output.</p></li><li><p>Otherwise, if <code>iterator</code> is empty:</p><ul><li><p>If <code>isconcretetype(eltype(iterator)) || (eltype(iterator) &lt;: Union{})</code>, <code>eltype(iterator)</code> is the output element type.</p></li><li><p>Otherwise, the output element type must be determined by <code>(c.empty_iterator_handler)(iterator)</code>.</p></li></ul></li><li><p>Otherwise, the output element type is the <code>typejoin</code> of the types of the elements of <code>iterator</code>.</p></li></ul><h3 id="Shape-of-the-output"><a class="docs-heading-anchor" href="#Shape-of-the-output">Shape of the output</a><a id="Shape-of-the-output-1"></a><a class="docs-heading-anchor-permalink" href="#Shape-of-the-output" title="Permalink"></a></h3><p>The shape of the output must be consistent with <code>output_type</code> (as already implied above).</p><p>To the extent that the shape is not specified by <code>output_type</code>, it is inferred from <code>Base.IteratorSize(iterator)</code>.</p><h3 id="Other-rules-for-implementers-to-follow"><a class="docs-heading-anchor" href="#Other-rules-for-implementers-to-follow">Other rules for implementers to follow</a><a id="Other-rules-for-implementers-to-follow-1"></a><a class="docs-heading-anchor-permalink" href="#Other-rules-for-implementers-to-follow" title="Permalink"></a></h3><p>Any added method must take exactly two arguments.</p><ul><li>If you disagree, open a feature request on Github to achieve agreement for adding to the interface.</li></ul><p>The first argument of any added method must be constrained to be a type (of type <code>Type</code>).</p><p>Make sure you own the constraint that is placed on the first argument. This is required even when you know you own the second argument.</p><ul><li><p>The rationale for this rule is to prevent causing ambiguity for other packages.</p></li><li><p>For example, defining a method with a signature like here is <em>not</em> allowed, because you do not own <code>Vector</code>, even if you do own <code>A</code>:</p><pre><code class="language-julia hljs">function (::Collect)(::Type{Vector}, ::A) end</code></pre></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 15 February 2026 22:50">Sunday 15 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
